## Introduction to Docker Compose

Docker Compose simplifies the process of managing multi-container Docker applications. Instead of running individual `docker run` commands for each container and manually configuring their networks and volumes, Docker Compose allows you to define your entire application stack in a single, declarative YAML file. This makes it easier to orchestrate complex applications, share them with others, and reproduce them across different environments. This lesson will cover the fundamentals of Docker Compose, including its syntax, commands, and how to use it to define and manage multi-container applications.

## Understanding Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications. It uses a YAML file to configure the application's services, networks, and volumes. With Compose, you can spin up your entire application stack with a single command, making it ideal for development, testing, and production environments.

### Key Concepts

* **docker-compose.yml**: This is the central configuration file for Docker Compose. It defines the services that make up your application, their dependencies, networks, volumes, and other configurations.
* **Services**: Each service in the `docker-compose.yml` file represents a container that will be run as part of your application. Services define the image to use, ports to expose, environment variables, and other container-specific settings.
* **Networks**: Docker Compose automatically creates a network for your application, allowing the services to communicate with each other using their service names as hostnames. You can also define custom networks for more complex scenarios.
* **Volumes**: Volumes allow you to persist data generated by your containers, even when the containers are stopped or removed. You can define volumes in the `docker-compose.yml` file and mount them to your services.

## Benefits of Using Docker Compose

* **Simplified Orchestration**: Compose simplifies the process of managing multi-container applications by allowing you to define the entire application stack in a single file.
* **Reproducibility**: Compose ensures that your application can be easily reproduced across different environments, as the configuration is defined in a declarative YAML file.
* **Isolation**: Compose creates a dedicated network for your application, isolating it from other applications running on the same host.
* **Scalability**: Compose allows you to easily scale your application by increasing the number of containers for each service.
* **Efficiency**: Compose streamlines the development workflow by allowing you to quickly spin up and tear down your entire application stack.

## Installing Docker Compose

Docker Compose is typically installed as part of Docker Desktop on Windows and macOS. On Linux, you may need to install it separately.

### Verifying Installation

To verify that Docker Compose is installed, open a terminal and run the following command:

```bash
docker-compose --version
```

This should print the version of Docker Compose installed on your system. If the command is not found, you may need to install Docker Compose separately. Refer to the official Docker documentation for installation instructions specific to your operating system.

## Creating a docker-compose.yml File

The `docker-compose.yml` file is the heart of Docker Compose. It defines the services, networks, and volumes that make up your application.

### Basic Structure

A basic `docker-compose.yml` file typically includes the following sections:

* `version`: Specifies the version of the Docker Compose file format.
* `services`: Defines the services that make up your application.
* `networks`: Defines the networks that your services will use.
* `volumes`: Defines the volumes that your services will use.

Here's a simple example of a `docker-compose.yml` file for a web application with a database:

```yaml
version: "3.9"
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./html:/usr/share/nginx/html
    depends_on:
      - db
    networks:
      - mynetwork

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: example
      POSTGRES_PASSWORD: example
      POSTGRES_DB: exampledb
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - mynetwork

networks:
  mynetwork:
    driver: bridge

volumes:
  db_data:
```

### Explanation of the Example

* `version: "3.9"`: Specifies that the Docker Compose file format version 3.9 is being used.
* `services`: Defines two services: `web` and `db`.

  * `web`:

    * `image: nginx:latest`: Uses the latest version of the Nginx image from Docker Hub.
    * `ports: - "80:80"`: Maps port 80 on the host to port 80 on the container.
    * `volumes: - ./html:/usr/share/nginx/html`: Mounts the `./html` directory on the host to `/usr/share/nginx/html` in the container.
    * `depends_on: - db`: Specifies that the `web` service depends on the `db` service.
    * `networks: - mynetwork`: Attaches the `web` service to the `mynetwork` network.
  * `db`:

    * `image: postgres:13`: Uses the PostgreSQL 13 image.
    * `environment`: Sets environment variables for PostgreSQL.
    * `volumes: - db_data:/var/lib/postgresql/data`: Mounts the volume to persist database data.
    * `networks: - mynetwork`: Attaches to the network.
* `networks`: Defines a custom network using the bridge driver.
* `volumes`: Defines a named volume `db_data`.

## Service Configuration Options

Each service in the `docker-compose.yml` file can be configured with various options:

* `image`: Docker image to use.
* `build`: Path to Dockerfile to build the image.
* `ports`: Map ports from host to container.
* `environment`: Set environment variables.
* `volumes`: Mount volumes.
* `depends_on`: Define dependencies.
* `restart`: Restart policy (e.g., `always`, `on-failure`).
* `command`: Override default command.
* `entrypoint`: Override default entrypoint.
* `networks`: Attach to networks.

### Example: Using build instead of image

```yaml
version: "3.9"
services:
  web:
    build: ./web
    ports:
      - "80:80"
    depends_on:
      - db
    networks:
      - mynetwork

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: example
      POSTGRES_PASSWORD: example
      POSTGRES_DB: exampledb
    volumes:
      - db_data:/var/lib/postgresql/data
    networks:
      - mynetwork

networks:
  mynetwork:
    driver: bridge

volumes:
  db_data:
```

## Docker Compose Commands

Docker Compose provides a set of commands for managing your application stack.

### Common Commands

* `docker-compose up`: Builds and starts containers.
* `docker-compose up -d`: Detached mode.
* `docker-compose down`: Stops and removes containers, networks, and volumes.
* `docker-compose start`: Starts existing containers.
* `docker-compose stop`: Stops running containers.
* `docker-compose restart`: Restarts running containers.
* `docker-compose ps`: Lists containers.
* `docker-compose logs`: View logs.
* `docker-compose exec`: Run command in container.
* `docker-compose build`: Builds services.
* `docker-compose pull`: Pulls service images.

### Example Usage

Start application:

```bash
docker-compose up -d
```

Stop application:

```bash
docker-compose down
```

View logs:

```bash
docker-compose logs web
```

Execute a command:

```bash
docker-compose exec web bash
```

## Practical Examples and Demonstrations

### Project Structure

```
.
├── docker-compose.yml
├── web
│   ├── Dockerfile
│   └── app.py
└── requirements.txt
```

### docker-compose.yml

```yaml
version: "3.9"
services:
  web:
    build: ./web
    ports:
      - "5000:5000"
    depends_on:
      - redis
    environment:
      - REDIS_HOST=redis
    networks:
      - mynetwork

  redis:
    image: redis:latest
    networks:
      - mynetwork

networks:
  mynetwork:
    driver: bridge
```

### web/Dockerfile

```dockerfile
FROM python:3.9-slim-buster

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

### web/app.py

```python
from flask import Flask
import redis
import os

app = Flask(__name__)
redis_host = os.environ.get('REDIS_HOST', 'localhost')
redis_client = redis.Redis(host=redis_host, port=6379)

@app.route('/')
def hello():
    redis_client.incr('hits')
    return 'Hello! This page has been visited {} times.\n'.format(redis_client.get('hits').decode('utf-8'))

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
```

### requirements.txt

```
flask
redis
```

### Running the Application

```bash
docker-compose up --build
```

Open browser: [http://localhost:5000](http://localhost:5000)

Stop:

```bash
docker-compose down
```

### Explanation

* Two services: `web` and `redis`.
* Flask app connects to Redis and increments counter.
* `Dockerfile` installs dependencies.

## Exercises

1. **Add a volume** to the `web` service to mount a directory at `/app/data`.
2. **Scale** the `web` service using:

```bash
docker-compose up --scale web=3
```

3. **Add environment variables** to configure Flask, e.g. `FLASK_DEBUG=1`.
4. **Implement healthcheck** to ensure readiness before accepting traffic.

## Summary and Next Steps

In this lesson, you learned about Docker Compose and how to use it to define and manage multi-container applications. Next, you'll explore Dockerfiles in more detail, learning best practices for writing efficient and secure Docker images.
